/*
 * Автор: Зорин Евгений
 * Управление нагрузкой 12В (Лента светодиодная) по датчику движения
 */
 
#include <avr/io.h>
#include <util/delay.h>

// ****************************************************************

  int vStat=0;  // Состояние света: 0 - выключено, 1 - включено
  int vTimer=0; // Счетчик таймера
  int vLimit=5; // Предел таймера в секундах (период сглаживания, сколько горит свет после "последнего движения")

// ****************************************************************

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Пoрт PB1 у нас выход - на него вешаем управление светом
 * Пoрт PB2 у нас вход  - на него вешаем датчик движения
 * 
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

int main( void )
{
  DDRB |= _BV (1); // pinMode (1, OUTPUT);
  // или другой вариант, более наглядный:
  // DDRB=0x02;    // устанавливаем вывод PB1 как выход, где
                   // 0x02 в шестнадцатиричной == 0b00010 в двоичной записи, где крайний правый - порт PB0
                   // При этом 0 - ввод (PINBx), 1 - вывод (PORTBx)

  while(1){        // основной цикл (структура другая, вместо loop)
    if(PINB & (1 << PINB2)){  // if(digitalRead(2) == HIGH) 
      PORTB |= (1<<1);        // включаем свет (устанавливаем высокий уровень на выводе PB1)
      vStat = 1;              // переключаем статус на включено.
      vTimer = 0;             // сбрасываем таймер, все ок.
    }
    if(vStat==1){     // Если свет включен
      vTimer +=1;
      _delay_ms(1);       // пауза, ~8 миллисекунд, опытным путем добыто знание
      if(vTimer == (vLimit * 125)){  // Если таймер достиг своего предела (_delay_ms(125) ~ 1 секунда)
        vStat = 0;                   // сбросим состояние
        vTimer = 0;                  // сбросим таймер
        PORTB &= ~(1<<1);            // выключаем свет (устанавливаем низкий уровень на выводе PB1)
      }
    }
  }
  return 0; // main почему-то нельзя сделать void, приходится возвращать хоть что-то, хотя оно и не нужно )
}
